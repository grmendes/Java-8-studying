package com.test.gmendes.stream.study.kotlin.v3

import com.test.gmendes.stream.study.Constants.LAYOUT_FILE_BASE_NAME
import com.test.gmendes.stream.study.Constants.LAYOUT_HEADER
import com.test.gmendes.stream.study.Constants.NULL
import com.test.gmendes.stream.study.Constants.SEPARATOR
import com.test.gmendes.stream.study.Constants.TXT_EXTENSION
import java.io.File
import java.nio.charset.StandardCharsets.ISO_8859_1

/**
 * This class contains the Kotlin based implementation of the project. The main goal is to process a batch of files,
 * generating SQL insert strings, as proof of concept.
 *
 * The main idea is to learn how to code using Kotlin into this implementation.
 *
 * This class holds basically the Kotlin's second version with plenty optimization. The main structure of code is used,
 * so the performance comparison is plenty reasonable.
 *
 * @author grmendes
 *
 * @version 3
 */
class ProcessKotlinV3(private val path: String) {

    /**
     * Entry point to start processing for testing. Generates a list of SQL inserts, based on the files processed.
     *
     * @return List of the generated inserts.
     */
    fun execute(): List<String> {
        return splitList(readFile(path, LAYOUT_FILE_BASE_NAME))
                .map { it[0] to it.minus(it[0]) }
                .map { validate(it) }
                .map {
                    it.first to it.second.minus(LAYOUT_HEADER)
                            .map { it.split(SEPARATOR.toRegex()).dropLastWhile { it.isEmpty() } }.sortedBy { it[0] }
                }
                .flatMap { process(it) }
                .toList()
    }

    /**
     * Validates the quality of input. This step is not strictly needed, but simulates a real scenario.
     * The data to process contains a file named layout.txt, which contains all tables, tables' columns and positional
     * information for data extraction. Also, there's a <TABLE_NAME>_layout.txt file with specific table columns
     * and positional information for data extraction. Both general layout and table specific layout files must contain
     * the same information. This method validates if both information are the same.
     *
     *
     * This method receives a list with the information from the general layout file (layoutList param) and
     * reads a list containing the information from the table's specific layout file. Then, it compares both with
     * List.containsAll method.
     *
     * @param pair Pair with the table's name as first and List of table's layout information as second.
     * @throws RuntimeException if results are not the same. Not supposed to occur.
     * @return The same input pair
     */
    private fun validate(pair: Pair<String, List<String>>): Pair<String, List<String>> {
        when { readFile(path,
                """${pair.first}_$LAYOUT_FILE_BASE_NAME""").toList() != pair.second -> throw RuntimeException(
                pair.first)
            else -> return pair
        }
    }

    /**
     * Receives a table's layout data, gets its data and generates inserts to this table with the data.

     * @param pair Pair with the table's name as first and List of table's layout information as second.
     * *
     * @return Sequence of String containing a SQL insert generated by the code.
     */
    private fun process(pair: Pair<String, List<List<String>>>): Sequence<String> {
        val baseInsertText =
                pair.second.joinToString(SEPARATOR, """INSERT INTO ${pair.first} (""", """) VALUES (""") { it[0] }

        return readFile(path, pair.first + TXT_EXTENSION).map { fileLine ->
            pair.second.asSequence().map { fileLine.substring(it[2].toInt(), it[3].toInt()) }
        }.map {
            """$baseInsertText${it.joinToString(SEPARATOR) {
                if (it.trim { it <= ' ' }.isEmpty()) NULL else it
            }});"""
        }
    }

    companion object {

        /**
         * Reads all file lines.
         *
         * Based on Kotlin default file reading code.
         *
         * @param path     Path to the file.
         * @param filename Name of the file.
         * @return Sequence of String with all file's lines.
         */
        fun readFile(path: String, filename: String): Sequence<String> {
            val list = ArrayList<String>()
            File(path, filename).useLines(ISO_8859_1, { it.forEach { list.add(it) } })
            return list.asSequence()
        }

        /**
         * Converts the received Sequence into a List of lists, splitting it by the predicate informed.
         *
         * @param list Sequence to be converted.
         * @return Sequence with a List of String elements.
         */
        fun splitList(list: Sequence<String>): Sequence<ArrayList<String>> {
            return list.fold<String, ArrayList<ArrayList<String>>>(arrayListOf(ArrayList()),
                    { array, string ->
                        when {
                            string.isEmpty() -> array.add(ArrayList())
                            else -> array.last().add(string)
                        }
                        array
                    }).asSequence()
                    .filter { it.isNotEmpty() }
        }
    }
}
